#!/usr/bin/env python2

import argparse, subprocess, sys, os
from buildconf import *

ROOT_DIR = os.path.abspath(os.path.dirname(__file__))

def parse_args(args):
    # Convert arguments to a dictionary
    params = vars(args)

    # CMake arguments from parameters
    cmakeargs = []
    for key in params.keys():
        # Ignore arguments that we are not interested in
        if key not in ("prefix", "build_type"):
            continue

        # Append the argument if makes sense
        if not params[key]:
            continue
        cmdname = key.upper()
        if key != "build_type":
            cmdname = "INSTALL_" + cmdname
        cmakeargs.append("-DCMAKE_%s=%s" % (cmdname, params[key]))

    return cmakeargs

def exec_cmd(cmd, workdir):
    try:
        shcmd = "cd %s && %s" % (workdir, cmd)
        print shcmd
        retcode = subprocess.call(shcmd, shell=True)
        if retcode < 0:
            print >>sys.stderr, "Child was terminated by signal", -retcode
            return False
        elif retcode != 0:
            print >>sys.stderr, "Child failed with exitcode", retcode
            return False
    except OSError, e:
        print >>sys.stderr, "Execution failed:", e
        return False

    return True

def build(args):
    modules = MODULES

    # Override modules with the ones from the command line
    if args.module:
        modules = args.module

    # Check whether all modules exists
    status = True
    for m in modules:
        if m not in MODULES:
            print >>sys.stderr, "Unknown '%s' submodule!" % m
            status = False
        elif os.path.exists(m):
            if not os.path.isdir(m):
                print >>sys.stderr, "Something is wrong with your setup, '%s' exists but it's not a directory" % m
                status = False
        else:
            print >>sys.stderr, "The '%s' submodule wasn't checked out, run ./init-repository fetch!" % m
            status = False
    if not status:
        return False

    # Build all modules
    for module in modules:
        if not build_module(module, args):
            return False
    return True

def build_module(module, args):
    # Ignore modules on the black list
    blacklist = args.blacklist if args.blacklist else []
    whitelist = args.whitelist if args.whitelist else []
    blacklist = list(set(IGNORED_MODULES + blacklist) - set(whitelist))
    if module in blacklist:
        return True

    # Build dependencies recursively
    dependencies = DEPENDENCIES[module].split(',') if DEPENDENCIES[module] else None
    if dependencies:
        for dependency in dependencies:
            build_module(dependency, args)

    import shutil

    print "===> Building %s ..." % module

    cmakeargs = parse_args(args)
    moduledir = os.path.join(ROOT_DIR, module)
    builddir = os.path.join(ROOT_DIR, "build")
    workdir = os.path.join(builddir, module)
    origworkdir = os.getcwd()
    retval = True

    # Create the build directory if it's either not found or we're in rebuild mode
    if not os.path.exists(os.path.join(workdir, COOKIENAME_CONFIGURE)) or args.rebuild:
        # Create the working directory
        if os.path.exists(workdir):
            shutil.rmtree(workdir)
        os.system("mkdir -p %s" % workdir)

        # Configure the submodule
        if args.verbose: print "Running cmake..."
        if not exec_cmd("cmake %s %s" % (" ".join(cmakeargs), moduledir), workdir):
            retval = False

        # Save the cookie
        if retval:
            if args.verbose: print "Saving the cookie..."
            if not exec_cmd("date > %s" % COOKIENAME_CONFIGURE, workdir):
                retval = False

    if retval:
        # Build
        if args.verbose: print "Running make..."
        makecmd = "make"
        if args.jobs:
            makecmd += " -j%d" % args.jobs
        if not exec_cmd(makecmd, workdir):
            retval = False

        # Save the cookie
        if retval:
            if args.verbose: print "Saving the cookie..."
            if not exec_cmd("date > %s" % COOKIENAME_BUILD, workdir):
                retval = False

    if retval:
        # Install
        if args.verbose: print "Running sudo make install..."
        if not exec_cmd("sudo make install", workdir):
            retval = False

    os.chdir(origworkdir)
    return retval

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("--verbose", action="store_true",
        help="verbose messages")
    parser.add_argument("--rebuild", action="store_true",
        help="rebuild already built modules")
    parser.add_argument("--build-type", metavar="TYPE", type=str, nargs='?',
        help="build type (possible values are Release, Debug and RelWithDebInfo)",
        default="RelWithDebInfo")
    parser.add_argument("--jobs", metavar="JOBS", type=int, nargs='?',
        help="sets the number of parallel jobs, usually it's recommended not to exceed NCORES + 1")
    parser.add_argument("--module", metavar="MODULE", type=str, nargs='*',
        help="build a specific set of modules")
    parser.add_argument("--whitelist", metavar="MODULE", type=str, nargs='*',
        help="build the module specified even if it's on the black list")
    parser.add_argument("--blacklist", metavar="MODULE", type=str, nargs='*',
        help="don't build the module specified by placing it on the black list")
    parser.add_argument("--prefix", metavar="PATH", type=str, nargs='?',
        help="installation prefix", default="/opt/hawaii")

    args = parser.parse_args()
    if not build(args):
        sys.exit(1)

# vim:set ts=4 sw=4 et:
