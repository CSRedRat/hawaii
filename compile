#!/usr/bin/env python

import argparse, subprocess, sys, os
from buildconf import *

ROOT_DIR = os.path.abspath(os.path.dirname(__file__))

def parse_args(args):
	# Convert arguments to a dictionary
	params = vars(args)

	# If --linux-fhs was passed we set the directory arguments with defaults
	# for standard Linux distributions
	if args.linux_fhs:
		params.update({
			"bindir": "bin",
			"appsdir": "share/applications",
			"progsdir": "bin",
			"serversdir": "bin",
			"sysconfdir": "/etc",
			"localstatedir": "/var",
			"libdir": "lib",
			"importsdir": "imports",
			"includedir": "include",
			"pkgconfig": "lib/pkgconfig",
			"cmakedir": "lib/cmake",
			"datarootdir": "share",
			"datadir": None,
			"docdir": None,
			"infodir": None,
			"mandir": None,
			"localedir": None
		})

	# CMake arguments from parameters
	cmakeargs = []
	for key in params.keys():
		# Ignore --verbose and --rebuild arguments
		if key in ("verbose", "rebuild"):
			continue

		# Append the argument if makes sense
		if not params[key]:
			continue
		cmdname = key.upper()
		if key != "build_type":
			cmdname = "INSTALL_" + cmdname
		cmakeargs.append("-DCMAKE_%s=%s" % (cmdname, params[key]))

	# Set CMake prefix path with the specified path
	if args.cmakedir:
		cmakeargs.append("-DCMAKE_PREFIX_PATH=%s/%s" % (args.prefix, args.cmakedir))

	return cmakeargs

def exec_cmd(cmd, workdir):
	try:
		shcmd = "cd %s && %s" % (workdir, cmd)
		print shcmd
		retcode = subprocess.call(shcmd, shell=True)
		if retcode < 0:
			print >>sys.stderr, "Child was terminated by signal", -retcode
			return False
		elif retcode != 0:
			print >>sys.stderr, "Child failed with exitcode", retcode
			return False
	except OSError, e:
		print >>sys.stderr, "Execution failed:", e
		return False

	return True

def build(args):
	for module in MODULES:
		if not build_module(module, args):
			return False
	return True

def build_module(module, args):
	# Ignore modules from the black list
	if module in IGNORED_MODULES:
		return True

	# Build dependencies recursively
	dependencies = DEPENDENCIES[module].split(',') if DEPENDENCIES[module] else None
	if dependencies:
		for dependency in dependencies:
			build_module(dependency, args)

	import shutil

	print "===> Building %s ..." % module

	cookiename = ".hawaii-ci-cookie"
	cmakeargs = parse_args(args)
	workdir = os.path.join(ROOT_DIR, module, "build")
	origworkdir = os.getcwd()
	retval = True

	# Create the build directory if it's either not found or we're in rebuild mode
	if not os.path.exists(os.path.join(workdir, cookiename)) or args.rebuild:
		if os.path.exists(workdir):
			shutil.rmtree(workdir)
		os.mkdir(workdir)

	if args.verbose: print "Running cmake..."
	if not exec_cmd("cmake %s .." % " ".join(cmakeargs), workdir):
		retval = False

	if retval:
		if args.verbose: print "Running make..."
		if not exec_cmd("make", workdir):
			retval = False

	if retval:
		if args.verbose: print "Running sudo make install..."
		if not exec_cmd("sudo make install", workdir):
			retval = False

	if retval:
		if args.verbose: print "Saving the cookie..."
		if not exec_cmd("date > %s" % cookiename, workdir):
			retval = False

	os.chdir(origworkdir)
	return retval

if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("--verbose", action="store_true",
		help="verbose messages")
	parser.add_argument("--rebuild", action="store_true",
		help="rebuild already built modules")
	parser.add_argument("--build-type", metavar="TYPE", type=str, nargs='?',
		help="build type (possible values are Release, Debug and RelWithDebInfo)",
		default="RelWithDebInfo")
	parser.add_argument("--linux-fhs", action="store_true",
		help="install software using Linux FHS")
	parser.add_argument("--prefix", metavar="PATH", type=str, nargs='?',
		help="installation prefix", default="/system")
	parser.add_argument("--bindir", metavar="PATH", type=str, nargs='?',
		help="binaries directory")
	parser.add_argument("--appsdir", metavar="PATH", type=str, nargs='?',
		help="desktop files directory")
	parser.add_argument("--progsdir", metavar="PATH", type=str, nargs='?',
		help="programs directory")
	parser.add_argument("--serversdir", metavar="PATH", type=str, nargs='?',
		help="server executables directory")
	parser.add_argument("--sysconfdir", metavar="PATH", type=str, nargs='?',
		help="system configuration directory")
	parser.add_argument("--localstatedir", metavar="PATH", type=str, nargs='?',
		help="modifiable single-machine data")
	parser.add_argument("--libdir", metavar="PATH", type=str, nargs='?',
		help="libraries directory")
	parser.add_argument("--pluginsdir", metavar="PATH", type=str, nargs='?',
		help="plugins directory")
	parser.add_argument("--importsdir", metavar="PATH", type=str, nargs='?',
		help="imports directory")
	parser.add_argument("--includedir", metavar="PATH", type=str, nargs='?',
		help="header files directory")
	parser.add_argument("--pkgconfigdir", metavar="PATH", type=str, nargs='?',
		help="pkg-config directory")
	parser.add_argument("--cmakedir", metavar="PATH", type=str, nargs='?',
		help="cmake directory")
	parser.add_argument("--datarootdir", metavar="PATH", type=str, nargs='?',
		help="data root directory")
	parser.add_argument("--datadir", metavar="PATH", type=str, nargs='?',
		help="data directory")
	parser.add_argument("--docdir", metavar="PATH", type=str, nargs='?',
		help="documentation directory")
	parser.add_argument("--infodir", metavar="PATH", type=str, nargs='?',
		help="info directory")
	parser.add_argument("--mandir", metavar="PATH", type=str, nargs='?',
		help="man directory")
	parser.add_argument("--localedir", metavar="PATH", type=str, nargs='?',
		help="locale directory")

	args = parser.parse_args()
	build(args)

# vim:set ts=4 sw=4 et:
